# 第15章 动态规划 Dynamic Programming 

动态规划通常用来解决最优化问题，在这类问题中，我们通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当其重复出现时即可避免重复求解。 

动态规划通常用于最优化问题，此类问题可能有很多可行解，每一个解有一个值，而我们希望找出一个具有最优值的解。

**通常按照四个步骤来设计一个动态规划算法**  

1）描述最优解的结构  
2）递归定义最优解的值  
3）按底向上的方式计算最优解的值  
4）由计算出的结果构造一个最优解  


## 15.1 钢条切割 

## 15.2 矩阵链乘法 

## 15.3 动态规划原理

- **最优子结构**：如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质。_无权最短路径 vs 无权最长路径_
- **重叠子问题**：如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。与之相对，适合用分治法求解的问题通常在递归的每一步都产生全新的子问题。
- **重构最优解**：通常将每个子问题所做的选择存在一个表中，如矩阵链乘法问题中的辅助表s[i,j]。

## 15.4 最长公共子序列 

longest-common-subsequence problem 

### 练习 

练习15.4-2 设计伪代码，利用完整的表 c 及原始序列 X 和 Y 来重构 LCS。要求运行时间为 O(m+n)，不能使用表 b。

练习 15.4-3 设计 LCS-LENGTH 的带备忘版本，运行时间为 O(mn)。

练习 15.4-4 说明如何只使用表 c 中 2*min(m, n) 个表项及 O(1) 的额外空间来计算 LCS 的长度。然后说明如何只用 min(m, n) 个表项及 O(1) 的额外空间完成相同的操作。  

练习15.4-5 设计一个 O(n^2) 时间的算法，求一个 n 个数的序列的**最长单调递增子序列**。

**分析**  
给定一个序列 X=<x1,x2,..,xn>，寻找为了寻找其最长单调递增子序列。  
step1: sort X=<x1,x2,..,xn> to X'=<x1',x2',..,xn'>，从小到大  
step2: LCS(X,X') yields the longest monotonically increasing subsequence of X  
运行时间为：O(n^2) 因为排序时间为 O(nlgn)，LCS 时间为 O(n^2)



## 15.5 最优二叉搜索树 

optimal binary search tree 
>对于一个给定的概率集合，我们希望构造一课期望搜索代价最小的二叉搜索树，称之为最优二叉树。
