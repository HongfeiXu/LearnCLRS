# 第16章 贪心算法 greedy algorithm

贪心算法就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。

## 16.1 活动选择问题

在活动选择问题中，我们希望选出一个最大兼容活动集。 

- 练习 16.1-4 区间图着色问题

## 16.2 贪心算法原理

1. 贪心选择性质
2. 最优子结构
3. 贪心 vs 动态规划 

0-1背包问题 与 分数背包问题

- 练习 16.2-2 设计动态规划算法求解 **0-1 背包问题**。要求运行时间为 O(nW)，n 为商品数量， W 是小偷能放进背包的最大商品总量。

问题分析：  
用动态规划解问题首先要找出子问题，可以通过这个子问题推得原问题的解。通常子问题的实质和原问题是相同的，只是规模上的缩小。  
也就是说子问题和原问题可以有相同的表示形式，问题可以通过不断的缩小规模（一般都会有一个界限）找到子问题的解。

这个问题要求解的是能用背包带走的最大价值，定义 **m[i,w]** 为：  
用第 1,2,3,...,i 个物品装入重量最大为 w 的背包的最大价值。

m[i,w] 的取值情况分析：

1. m[0, w] = 0  背包重量最大为w，里面没有物品，价值为0
2. m[i, 0] = 0  背包重量最大为0，所以没法装任何东西，价值为0

对任意的第 i 个物品，有两种情况，放进背包或者不放

1. 如果 wi > w，由于第 i 个物品的重量大于背包的容量，所以不可放入，则 **m[i, w] = m[i-1, w]**
2. 如果 wi < w，则物品可以放入背包也可以不放入，取较大的值，即 **m[i, w] = max(m[i-1, w], m[i-1, w-wi] + vi)**

在这个问题中，定义了子问题：m[i, w]，且对于每个子问题都可以通过上面的分析求出。通过上面的分析可以发现，每一次求取子问题，问题的规模就被缩小，要么 w 在减小，要么 i 在减小。最后问题的规模会被缩小为 m[1, 0] 和 m[0, w]，均为一值。逆向推回去就能得到问题的解。


```c++
DPKnapsack(i1,i2,...,in;w1,...,wn;v1,...,vn,W)
For i=1 to n do
    m[i,0] = 0
For w=0 to W do
    m[0,w] = 0
For i=1 to n do
    For w=1 to W do
        if wi>W then 
            m[i,w]=m[i-1,w]
        else
            m[i,w]=max{m[i-1,w],m[i-1,w-wi]+vi}
Return m[n,w]
```

时间复杂度 O(nW)

## 16.3 赫夫曼编码

### 基本思想

采用变长编码，赋予高频字符短码字。使用前缀码（没有任何码字是其他码字的前缀）。与任何字符编码相比，前缀编码可以保证得到最优数据压缩率。  
算法自底向上地构造出对应最优编码的二叉树 T。使用一个**以属性 freq 为关键字的最小优先队列 Q**，以识别两个频率最低的对象并将其合并。当合并两个对象时，得到的新对象的频率设置为原来两个对象的频率之和。


### Pseudocode

输入：C[1..n] n个字符的集合，每个字符 c 是一个对象，具有属性 c.freq 为字符的出现频率。

```c++
HUFFMAN(C)
n = |C|
Q = C
for i = 1 to n-1
    allocate a new node z
    z.left = x = EXTRACT-MIN(Q)
    z.right = y = EXTRACT-MIN(Q)
    z.freq = x.freq + y.freq
    INSERT(Q, z)
return EXTRACT-MIN(Q)
```

